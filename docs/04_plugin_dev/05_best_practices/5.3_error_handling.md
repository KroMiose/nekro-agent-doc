# 5.3 错误处理

健壮的错误处理是插件稳定性和用户体验的关键。一个好的插件应该能够预见并妥善处理潜在的错误，而不是意外崩溃或导致不可预测的行为。

## 1. 错误处理的重要性

- **提升稳定性**：防止插件因未捕获的异常而崩溃，从而影响整个 Nekro Agent 系统的稳定性。
- **改善用户体验**：向用户提供清晰、有用的错误信息，帮助他们理解问题所在以及如何解决。
- **便于调试**：详细的错误日志可以帮助开发者快速定位和修复 bug。
- **资源管理**：确保在发生错误时，插件占用的资源（如文件句柄、网络连接等）能够被正确释放。

## 2. 使用 `try-except` 块

Python 的 `try-except` 语句是处理异常的基础。将可能引发异常的代码块放入 `try` 子句中，并在 `except` 子句中处理这些异常。

```python
from nekro_agent.utils.common import logger

try:
    # 可能会抛出异常的代码
    result = 10 / 0
except ZeroDivisionError as e:
    logger.error(f"计算错误：除数为零。详情: {e}")
    # 通知用户或返回一个错误提示
    # nekro_agent.api.message.send_text("计算时发生错误，请检查您的输入。")
except Exception as e:
    logger.error(f"发生了一个未知错误: {e}")
    # 处理其他所有类型的异常
```

## 3. 捕获特定异常

尽量捕获最具体的异常类型，而不是简单地使用 `except Exception:`。这有助于更精确地处理不同类型的错误，并避免意外捕获不应由该代码块处理的异常（如 `KeyboardInterrupt` 或 `SystemExit`）。

- **优点**：
    - 更清晰的错误处理逻辑。
    - 避免掩盖其他不相关的错误。
- **示例**：
    ```python
    try:
        with open("some_file.txt", "r") as f:
            content = f.read()
        data = int(content)
    except FileNotFoundError:
        logger.error("错误：文件未找到。")
        # 处理文件不存在的情况
    except ValueError:
        logger.error("错误：文件内容无法转换为整数。")
        # 处理数据转换失败的情况
    except Exception as e:
        logger.error(f"处理文件时发生未知错误: {e}")
    ```

## 4. 使用 `plugin.logger` 进行日志记录

Nekro Agent 为每个插件实例提供了 `plugin.logger` 对象，用于记录日志。这是记录插件运行情况和错误信息的推荐方式。

- **特性**：
    - 日志会自动包含插件名称和上下文信息。
    - 支持不同的日志级别（`DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`）。
    - 日志会统一由 Nekro Agent 系统管理。

```python
# 在你的 plugin.py 中
# from nekro_agent.services.plugin.models import NekroPlugin
# plugin = NekroPlugin(...)

# 在你的方法中
try:
    # ...
    pass
except Exception as e:
    plugin.logger.error(f"插件执行出错: {e}", exc_info=True) # exc_info=True 会记录堆栈跟踪信息
```

## 5. 提供有意义的错误信息

当错误发生时，如果需要通知用户，应提供清晰、简洁且有用的错误信息。避免直接暴露原始的、技术性的错误堆栈给最终用户。

- **对用户友好**：解释发生了什么，以及用户可能需要做什么。
- **对开发者友好（日志中）**：记录足够的技术细节，包括错误类型、消息和堆栈跟踪。

## 6. 优雅降级

如果插件的某个部分发生错误，尝试让插件的其他功能仍然可用，或者至少以一种可控的方式失败。

例如，如果一个获取天气信息的插件无法连接到天气 API，它可以返回一个友好的提示（"暂时无法获取天气信息，请稍后再试"），而不是完全崩溃。

## 7. 清理资源

使用 `finally` 子句或 `plugin.mount_cleanup_method` 来确保即使在发生错误时，插件分配的资源（如文件句柄、数据库连接、网络套接字等）也能被正确释放。

### 使用 `finally`

```python
file = None
try:
    file = open("important_data.txt", "w")
    file.write("some data")
    # ... 其他操作 ...
except IOError as e:
    plugin.logger.error(f"文件操作失败: {e}")
finally:
    if file:
        file.close()
        plugin.logger.info("文件已关闭。")
```

### 使用 `plugin.mount_cleanup_method`

对于插件级别的资源清理（例如，在插件卸载或会话重置时需要执行的清理操作），应使用 `@plugin.mount_cleanup_method()` 装饰器。

```python
from nekro_agent.services.plugin.models import NekroPlugin, CurrentPluginContext

plugin = NekroPlugin(
    name="resource_manager_plugin",
    description="演示资源清理的插件",
    version="0.1.0",
    author="Nekro"
)

# 假设有一个需要管理的资源
plugin_resource = None

@plugin.mount_init_method()
async def init_plugin(ctx: CurrentPluginContext):
    global plugin_resource
    plugin_resource = {"data": "initialized"} # 模拟资源初始化
    plugin.logger.info("插件资源已初始化。")

@plugin.mount_cleanup_method()
async def cleanup_plugin(ctx: CurrentPluginContext):
    global plugin_resource
    if plugin_resource:
        # 执行清理操作，例如关闭连接、释放内存等
        plugin_resource = None
        plugin.logger.info("插件资源已成功清理。")
    else:
        plugin.logger.info("无需清理插件资源。")

# ... 其他插件方法 ...
```
当插件被卸载或系统触发清理时（例如会话重置），`cleanup_plugin` 方法会被调用。

## 总结

良好的错误处理策略是构建高质量插件的基石。通过仔细考虑潜在的故障点并实施健壮的错误处理机制，可以显著提高插件的可靠性和用户满意度。 