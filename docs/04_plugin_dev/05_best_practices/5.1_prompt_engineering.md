\
---
title: 提示词工程 (Prompt Engineering)
description: Nekro Agent 插件开发中的提示词工程最佳实践，为沙盒方法设计清晰的文档字符串，为提示词注入撰写有效的引导文本，以提升 AI 的理解和执行能力。
---

# 提示词工程 (Prompt Engineering)

在 Nekro Agent 插件开发中，提示词工程 (Prompt Engineering) 是一项至关重要的技能。AI 的行为和插件的效用在很大程度上取决于你提供给 AI 的"提示"——这包括沙盒方法的文档字符串 (docstrings)、方法描述 (descriptions) 以及通过提示词注入 (prompt injection) 提供的动态文本。

有效的提示词能够帮助 AI：

*   **准确理解功能**：知道你的插件和方法能做什么，不能做什么。
*   **正确调用方法**：理解参数的含义、类型和格式。
*   **合理预期结果**：知道调用后会得到什么样的输出。
*   **遵循特定行为或角色**：根据你的引导调整其响应风格和思考模式。

本节将探讨为沙盒方法和提示词注入设计高质量提示的最佳实践。

## 1. 沙盒方法的文档字符串 (Docstrings) 和描述

AI 依赖沙盒方法的 `name` (调用名称)、`description` (在 `@plugin.mount_sandbox_method` 中提供) 和函数自身的详细文档字符串 (docstring) 来理解如何使用该方法。这是"工具使用"场景下的核心提示。

### 关键原则：

*   **清晰、准确、完整**：
    *   `name`: 简洁且能概括功能，通常使用 `snake_case`。
    *   `description`: 一句话清晰描述方法的核心功能和用途。这是 AI 初步筛选工具的重要依据。
    *   `docstring`: 提供最详尽的信息。
*   **结构化文档字符串**：推荐使用 Google 风格或 Numpy 风格的文档字符串。
    *   **摘要行**：简明扼要地概括函数功能。
    *   **详细描述 (可选)**：如果需要，进一步阐述工作原理、前置条件、副作用等。
    *   **`Args:` 段落**：
        *   列出**所有**参数（除了 `ctx`）。
        *   指明每个参数的 `名称 (类型): 描述`。
        *   类型应与函数签名中的类型注解一致。
        *   描述应清晰说明参数的含义、预期格式、可选值范围等。
        *   如果参数是可选的，应明确指出并说明其默认行为。
    *   **`Returns:` 段落**：
        *   指明 `类型: 描述`。
        *   类型应与函数签名中的返回类型注解一致。
        *   描述应清晰说明返回值的结构和含义。
        *   对于不同 `SandboxMethodType`，返回值的意义和格式有特定要求，务必在描述中体现（例如，`AGENT` 类型返回的字符串是给 AI 看的观察结果）。
    *   **`Example:` 段落 (强烈推荐)**：
        *   提供一个或多个 AI 可以直接理解和模仿的 Python 调用示例，用 Markdown 代码块包围。
        *   示例应展示典型的使用场景和参数组合。
        *   这对于复杂参数或行为的方法尤其重要，AI 可以通过"示例学习" (few-shot learning) 的方式更快掌握用法。
    *   **`Raises:` 段落 (可选但推荐)**：
        *   说明方法在何种情况下可能抛出哪些类型的异常，帮助 AI 预判和处理潜在问题。
*   **与类型注解一致**：文档字符串中声明的参数和返回类型必须与 Python 的类型注解严格对应。
*   **面向 AI 设计**：记住这些文档是写给 AI 看的。使用 AI 更容易理解的自然语言，避免过于技术化或含糊不清的内部术语（除非这些术语是 AI 需要学习的领域知识）。
*   **强调关键信息**：对于重要的限制、默认行为或副作用，可以在描述中加以强调。

### 示例：一个精心设计的沙盒方法提示

```python
@plugin.mount_sandbox_method(
    method_type=SandboxMethodType.TOOL,
    name="schedule_meeting",
    description="安排一个新的会议，并将其添加到日历中。会检查参与者是否有空。"
)
async def schedule_meeting_tool(
    ctx: AgentCtx, 
    title: str, 
    participants: List[str], 
    start_time_iso: str, 
    duration_minutes: int = 30,
    location: Optional[str] = None
) -> Dict[str, Any]:
    """安排一个新会议并返回会议详情或冲突信息。

    此工具会尝试在指定时间为所有参与者安排会议。
    它会检查参与者的日历以避免冲突。
    如果成功，返回会议的详细信息，包括会议 ID。
    如果存在冲突或无法安排，将返回错误信息和冲突详情。

    Args:
        ctx (AgentCtx): 会话上下文，未使用。
        title (str): 会议的标题。
        participants (List[str]): 参与者的邮箱地址或用户 ID 列表。
        start_time_iso (str): 会议开始时间，ISO 8601 格式 (例如, "2024-07-15T14:30:00+08:00")。
        duration_minutes (int, optional): 会议持续时间（分钟）。默认为 30 分钟。
        location (Optional[str], optional): 会议地点或在线会议链接。默认为 None。

    Returns:
        Dict[str, Any]: 一个包含会议安排结果的字典。
            如果成功，格式为: {"status": "success", "meeting_id": "cal_evt_xxx", "title": "...", ...}
            如果失败，格式为: {"status": "error", "message": "...", "conflicts": [...]}
    
    Example:
        ```python
        # 安排一个30分钟的团队会议
        meeting_details = schedule_meeting(
            title="团队周会",
            participants=["user1@example.com", "user2@example.com"],
            start_time_iso="2024-09-01T10:00:00Z",
            location="在线会议室 A"
        )
        if meeting_details["status"] == "success":
            print(f"会议已安排，ID: {meeting_details['meeting_id']}")
        else:
            print(f"会议安排失败: {meeting_details['message']}")
        ```
    """
    # ... 实际的会议安排逻辑 ...
    pass
```

## 2. 提示词注入 (`@plugin.mount_prompt_inject_method()`)

通过提示词注入返回的字符串会被直接添加到 AI 的主系统提示中。这部分内容对 AI 的行为模式、角色认知和上下文理解有直接影响。

### 关键原则：

*   **明确目的**：清楚你希望通过注入的提示达到什么效果？是提供信息、设定角色、约束行为，还是引导思考方向？
*   **简洁、直接、无歧义**：AI 对系统提示非常敏感。注入的文本应尽可能简短、清晰，避免使用模糊或可能引起误解的措辞。
*   **结构化信息**：如果要注入多条离散信息，使用换行符、项目符号或清晰的标题/标签来分隔它们，帮助 AI 解析。
    *   例如：`"用户偏好：
    - 主题：暗色
    - 通知：开启
当前知识库状态：包含3篇关于 'Python 异步编程' 的文章。"`
*   **动态与相关性**：注入的提示词应该是动态生成的，并且与当前会话 (`AgentCtx`) 或用户高度相关。避免注入通用的、与当前情境无关的信息。
*   **角色扮演引导 (如果适用)**：
    *   明确指示 AI 扮演的角色："你是一个专业的股票分析师。"
    *   描述角色的关键特征和行为方式："你的回答应该基于数据，避免个人猜测，并使用专业的金融术语。"
*   **能力与工具提示 (谨慎使用)**：
    *   可以简要提醒 AI 它拥有哪些通过本插件提供的关键能力或工具，尤其是当这些能力与当前注入的上下文信息相关时。
    *   但**不要**在提示词注入中重复沙盒方法文档字符串的详细内容。AI 主要通过方法签名和文档来学习工具的具体用法。
    *   例如：`"背景信息：用户正在查询航班。提示：你可以使用 'search_flights' 工具查找航班信息。"`
*   **避免信息过载**：系统提示的长度是有限的，过多或过于复杂的注入内容可能会降低整体提示的质量，甚至被 AI 忽略。
*   **上下文关联**：尽量使注入的提示与对话的自然流程相关联。例如，如果用户刚刚完成某项操作，可以注入与该操作结果相关的后续提示。
*   **清晰指令 vs. 开放式引导**：
    *   **清晰指令**："当用户询问天气时，总是先调用 `get_current_weather` 工具，然后总结结果。" (更偏向规则)
    *   **开放式引导**："你是一个乐于助人且知识渊博的助手，请尽你所能回答用户关于历史的问题，可以参考你所连接的知识库。" (更偏向角色和风格)
    *   根据需求选择合适的引导方式。
*   **占位符与模板**：如果注入的提示词有固定的结构，可以使用模板字符串和占位符来动态填充内容，使代码更清晰。
*   **测试与迭代！**：提示词工程没有一劳永逸的解决方案。针对你的具体插件和目标用户，不断测试不同版本的注入提示词，观察 AI 的行为变化，并进行迭代优化。这是最重要的一环。

### 示例：动态注入用户偏好和上下文

```python
@plugin.mount_prompt_inject_method(name="user_context_injection")
async def inject_user_context(ctx: AgentCtx) -> str:
    prompts = []
    
    # 从插件存储获取用户偏好的语言
    user_lang = await plugin.store.get(user_key=ctx.from_user_id, store_key="preferred_language")
    if user_lang:
        prompts.append(f"用户信息：用户的偏好语言是 '{user_lang}'。请尽可能使用此语言回复。")
    
    # 获取当前会话的主题（如果插件维护了这个状态）
    session_topic = await plugin.store.get(chat_key=ctx.from_chat_key, store_key="current_topic")
    if session_topic:
        prompts.append(f"当前会话上下文：我们正在讨论关于 '{session_topic}' 的话题。")
        # 可以进一步提示相关工具
        if session_topic == "项目管理":
            prompts.append("提示：你可以使用 'create_task' 或 'list_tasks' 等工具管理项目任务。")
            
    if not prompts:
        return "" # 如果没有特定信息，不注入
        
    return "\n".join(prompts)
```

## 总结

高质量的提示词是连接插件功能与 AI 理解能力的桥梁。通过精心设计沙盒方法的文档字符串和巧妙运用提示词注入，你可以极大地提升插件的可用性、可靠性和用户体验。

记住，提示词工程是一个持续优化的过程。多加测试，观察 AI 的反应，并根据反馈不断调整你的提示策略。 