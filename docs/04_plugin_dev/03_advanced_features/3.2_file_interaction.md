\
---
title: 文件交互
description: 学习 Nekro Agent 插件中处理文件（读写、路径转换）的机制和最佳实践，理解沙盒与主服务环境差异，以及数据序列化注意事项。
---

# 文件交互

插件经常需要与文件系统进行交互，例如读取用户上传的文件、写入处理结果、加载大型数据资源等。然而，由于 Nekro Agent 的沙盒执行机制，插件开发者在处理文件路径时必须格外小心，并理解沙盒环境与主服务执行环境之间的差异。

## 沙盒与主服务的路径差异

如前所述，插件的沙盒方法虽然由沙盒中的 AI 代码调用，但其实际执行发生在 Nekro Agent 的主服务进程中。这两个环境拥有不同的文件系统视图：

*   **沙盒环境**：通常是一个容器化的、受限的文件系统。沙盒中的代码看到的路径（例如，`/app/uploads/somefile.txt`）可能与主服务中的实际物理路径完全不同。
*   **主服务环境**：Nekro Agent 核心进程运行的环境，拥有对系统文件（如 `data/` 目录）的直接访问权限。

**直接在沙盒方法中返回或使用硬编码的沙盒内部路径是错误的，因为这些路径在主服务中通常无效，反之亦然。**

## 路径转换工具

为了解决这个问题，Nekro Agent 提供了一套路径转换工具，帮助你在沙盒路径和主服务可访问路径之间进行映射。

```python
from nekro_agent.tools.path_convertor import (
    convert_to_container_path,  # 将主机路径转换为沙盒容器内可访问的路径
    convert_to_host_path,      # 将沙盒容器内路径转换为主机可访问的物理路径
    is_url_path,               # 检查路径是否为 URL
    PathLocation               # 枚举，定义了常见的路径位置类型
)
from nekro_agent.api.schemas import AgentCtx # 需要 AgentCtx 来确定上下文
```

### `PathLocation` 枚举

`PathLocation` 定义了几种预设的、Nekro Agent 管理的文件存储区域，方便进行路径转换：

*   `PathLocation.UPLOADS`: 用户上传文件的目录。
    *   沙盒视角: 通常是类似 `/app/uploads/` 的路径。
    *   主机视角: 对应于 `data/uploads/{chat_key}/` 或类似的、按会话隔离的物理路径。
*   `PathLocation.SHARED`: 沙盒与主机共享的目录，通常用于临时文件交换。
    *   沙盒视角: 通常是类似 `/app/shared/` 的路径。
    *   主机视角: 对应于 `data/sandboxes/{container_key}/shared/` 或类似的、按沙盒实例隔离的物理路径。
*   `PathLocation.PLUGIN_DATA`: 插件自身的持久化数据目录 (`plugin.get_plugin_path()`)。
    *   主机视角: `data/plugins/{plugin_author}.{plugin_module_name}/`。
    *   转换到沙盒: 可能需要特定配置或不支持直接映射，取决于沙盒实现。

### 路径转换函数

*   **`convert_to_host_path(container_path: str, chat_key: Optional[str] = None, location: PathLocation = PathLocation.UPLOADS) -> str`**
    *   将沙盒容器内的相对或绝对路径，根据 `location` 和可选的 `chat_key`（对于 `UPLOADS` 位置尤其重要），转换为主机操作系统可以访问的物理路径。
    *   **何时使用**：当你的沙盒方法接收到一个来自 AI（在沙盒中）的文件路径参数时，你需要用此函数将其转换为主服务可以实际读写该文件的路径。

*   **`convert_to_container_path(host_path: str, chat_key: Optional[str] = None, location: PathLocation = PathLocation.UPLOADS) -> str`**
    *   将主服务中的物理路径，根据 `location` 和可选的 `chat_key`，转换为沙盒容器内可以引用的路径。
    *   **何时使用**：当你的插件在主服务中生成了一个文件，并且需要将这个文件的路径返回给 AI（在沙盒中）以便其后续使用（例如，在生成的代码中引用该文件）时。

**重要原则：**

*   **输入转换**：如果沙盒方法接收来自 AI 的文件路径参数，立即使用 `convert_to_host_path` 将其转换。
*   **输出转换**：如果沙盒方法需要返回文件路径给 AI，请确保返回的是使用 `convert_to_container_path` 转换后的沙盒可访问路径。
*   **避免直接返回主机路径给 AI**：AI 在沙盒中无法直接访问主机物理路径。
*   **优先传递内容或引用而非路径**：如果可能，优先直接处理文件内容并返回结果，或者返回一个可供 AI 理解的抽象引用（如下载链接），而不是直接传递文件系统路径，以减少路径转换的复杂性和潜在错误。

**示例：处理 AI 提供的上传文件路径**

```python
import aiofiles
from nekro_agent.api import core

@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "process_uploaded_image", "处理用户上传的图片文件。")
async def process_image(ctx: AgentCtx, image_sandbox_path: str) -> str:
    """接收沙盒中的图片路径，在主服务中处理它。

    Args:
        ctx (AgentCtx): 会话上下文。
        image_sandbox_path (str): AI 在沙盒中看到的图片路径。

    Returns:
        str: 处理结果的描述。
    """
    try:
        # 1. 将沙盒路径转换为主机可访问路径
        # 假设文件位于用户上传区域，需要 ctx.from_chat_key 来定位
        host_image_path = convert_to_host_path(
            container_path=image_sandbox_path, 
            chat_key=ctx.from_chat_key, # 关键：通常上传与会话关联
            location=PathLocation.UPLOADS
        )
        core.logger.info(f"接收到沙盒路径 '{image_sandbox_path}'，转换为主机路径 '{host_image_path}'")

        # 2. 在主服务中读取和处理文件
        if not Path(host_image_path).exists():
            return f"错误：文件在主机路径 '{host_image_path}' 未找到。可能是路径转换错误或文件确实不存在。"

        async with aiofiles.open(host_image_path, "rb") as f:
            image_data = await f.read()
        
        # ... 在这里进行图片处理 (例如：分析、缩放、添加滤镜等) ...
        # processed_result = await image_processing_library(image_data)
        
        return f"图片 '{Path(host_image_path).name}' 处理成功。大小: {len(image_data)} 字节。"
    
    except Exception as e:
        core.logger.error(f"处理图片 '{image_sandbox_path}' 失败: {e}")
        return f"处理图片失败: {e}"

```

**示例：插件生成文件并返回沙盒路径给 AI**

```python
from pathlib import Path

@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "generate_report_file", "生成一份报告并返回其沙盒路径。")
async def generate_report(ctx: AgentCtx, report_data: str) -> str:
    """生成报告文件，并返回 AI 可在沙盒中使用的路径。

    Args:
        ctx (AgentCtx): 会话上下文。
        report_data (str): 报告的内容。

    Returns:
        str: 生成的报告文件在沙盒中的可访问路径。
    """
    # 1. 在主服务中生成文件 (例如在插件的共享数据区或会话上传区)
    # 我们选择在当前会话的上传区生成，这样更符合逻辑
    # 先确定主机物理路径
    report_filename = f"report_{int(time.time())}.txt"
    
    # 获取会话上传目录的主机基本路径
    # 注意: 实际实现中，core.config 或 ctx 可能提供更直接的方式获取会话上传目录主机路径
    # 这里简化为使用 convert_to_host_path 的反向思维来构造一个预期的主机路径前缀
    # 更好的方式是有一个专门的函数 get_host_upload_dir(chat_key)
    # 假设我们希望文件最终在 data/uploads/{chat_key}/reports/ 目录下
    # 这是个略微复杂的点，因为 convert_to_host_path 通常用于已存在的沙盒路径
    # 更稳妥的做法是插件拥有自己的固定可写目录，或使用一个API来获取可写的临时目录的主机路径

    # 简单示例：使用插件自身的数据目录 plugin.get_plugin_path()
    plugin_dir = plugin.get_plugin_path()
    reports_output_dir = plugin_dir / "generated_reports"
    reports_output_dir.mkdir(parents=True, exist_ok=True)
    host_report_path = reports_output_dir / report_filename

    async with aiofiles.open(host_report_path, "w", encoding='utf-8') as f:
        await f.write(report_data)
    core.logger.info(f"报告已生成在主机路径: {host_report_path}")

    # 2. 将主机路径转换为沙盒可访问路径
    # 由于此文件不在标准的 UPLOADS 或 SHARED (从沙盒角度)，转换可能复杂
    # 最简单的情况是如果插件的 plugin_path 本身就被映射到了沙盒的某个固定位置
    # 假设 plugin.get_plugin_path() 返回的路径在主机上是 /data/plugins/myauthor.myplugin
    # 并且沙盒可以看到它，例如映射为 /mnt/plugins/myauthor.myplugin
    # 那么 container_report_path = f"/mnt/plugins/myauthor.myplugin/generated_reports/{report_filename}"
    # 这需要对 Agent 的部署和沙盒挂载有深入了解，或者框架提供更直接的转换支持。

    # 理想情况下，如果文件生成在与会话关联的 UPLOADS 区域，转换会更直接：
    # 假设我们通过某种方式得到了会话上传区的主机路径 host_upload_dir_for_session
    # host_report_path = host_upload_dir_for_session / report_filename
    # ... 写入文件 ...
    # container_report_path = convert_to_container_path(
    #     host_path=str(host_report_path),
    #     chat_key=ctx.from_chat_key,
    #     location=PathLocation.UPLOADS
    # )
    # return container_report_path

    # **重要**: 由于上述转换的复杂性，更推荐的做法是：
    # 1. 插件生成文件到其专属目录 `plugin.get_plugin_path()` 下。
    # 2. 如果需要 AI 直接访问，插件应将此文件通过消息服务 API (如 `message.send_file`) 发送给用户。
    #    AI 通常可以通过收到的消息引用或下载链接来间接访问文件，而不是直接通过文件系统路径。
    # 3. 或者，如果 AI 确实需要路径，确保你的部署方案支持将插件数据目录可靠地映射到沙盒，并硬编码或通过配置告知沙盒该映射路径。
    
    # 简化并采取推荐做法：返回一个提示，而不是直接返回沙盒路径
    # await message.send_file(ctx.from_chat_key, str(host_report_path), ctx, filename=report_filename)
    # return f"报告 '{report_filename}' 已生成。我会通过消息发送给你。" 
    # 或者，如果只是为了让AI知道，而不直接操作：
    return f"报告 '{report_filename}' 已在服务器端生成于路径 '{host_report_path}'。"

```
在第二个示例中，关于将主机路径转换为沙盒路径的部分突显了一个复杂点：除非文件位于 Agent 标准管理的 `UPLOADS` 或 `SHARED`（从沙盒视角）区域，否则通用的路径转换可能不直接适用或需要对部署有深入了解。因此，更稳妥的做法通常是：
1.  插件将生成的文件保存到其通过 `plugin.get_plugin_path()` 获取的专属目录中。
2.  通过消息 API（如 `message.send_file`）将文件发送给用户/会话。
3.  如果 AI 需要知晓，可以返回文件的描述、名称或一个抽象的引用，而不是一个需要 AI 直接操作的文件系统路径。

## 异步文件操作

由于 Nekro Agent 是基于异步 (`asyncio`) 构建的，所有耗时的 I/O 操作（包括文件读写）都应该使用异步方式进行，以避免阻塞主事件循环。推荐使用 `aiofiles` 库进行异步文件操作。

```python
import aiofiles

async def read_file_content(file_path: str) -> str:
    try:
        async with aiofiles.open(file_path, mode="r", encoding="utf-8") as f:
            content = await f.read()
        return content
    except FileNotFoundError:
        core.logger.error(f"文件未找到: {file_path}")
        return ""
    except Exception as e:
        core.logger.error(f"读取文件 {file_path} 失败: {e}")
        return ""
```

## 数据序列化与文件交互

当沙盒方法通过 RPC 与主服务通信时，其参数和返回值会通过 `pickle` 进行序列化和反序列化。这带来一些限制：

*   **可序列化类型**：只支持 Python 内置的基本类型（str, int, list, dict 等）以及正确实现了 `__getstate__` 和 `__setstate__` 的自定义类的实例。
*   **不可直接传递对象**：文件句柄、网络连接、数据库连接等包含运行时状态的复杂对象不能直接在沙盒方法参数或返回值中传递。
*   **数据大小限制**：避免通过 RPC 传递非常大的数据块（如整个大文件的内容），这可能导致性能问题或超出序列化限制。对于大型数据，应考虑：
    1.  将数据保存到文件系统（使用上述路径转换和异步操作）。
    2.  在沙盒方法的参数或返回值中传递文件的引用（如转换后的沙盒路径或下载 URL）。
    3.  AI 或插件的另一部分再根据此引用去读取文件内容。

**错误示例（传递文件句柄）：**

```python
# 错误！文件句柄不可序列化
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "get_file_handle_WRONG", "")
async def get_file_handle(ctx: AgentCtx, host_path: str):
    f = open(host_path, "r")
    return f # 这是错误的！
```

**正确做法（传递内容或路径）：**

```python
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "get_file_content_CORRECT", "")
async def get_file_content(ctx: AgentCtx, sandbox_path: str) -> str:
    host_path = convert_to_host_path(sandbox_path, ctx.from_chat_key, PathLocation.UPLOADS)
    async with aiofiles.open(host_path, "r") as f:
        content = await f.read()
    return content # 返回可序列化的字符串内容
```

## 最佳实践总结

1.  **始终转换路径**：从 AI 获取路径用 `convert_to_host_path`，向 AI 提供路径用 `convert_to_container_path`（如果适用且明确）。
2.  **理解 `PathLocation`**：正确使用 `UPLOADS` 和 `SHARED` 等位置类型。
3.  **使用插件专属目录**：通过 `plugin.get_plugin_path()` 获取插件的数据目录，用于存储插件自身的持久化文件。
4.  **异步操作优先**：使用 `aiofiles` 等进行文件 I/O。
5.  **谨慎传递路径给 AI**：优先传递文件内容、处理结果或可通过其他方式（如下载链接、消息发送）访问的引用，而不是裸文件系统路径，尤其是对于插件生成的文件。
6.  **注意序列化限制**：不要在 RPC 调用中传递大型数据或不可序列化的对象；应通过文件系统作为中介。
7.  **权限和安全**：确保插件只在授权的目录中读写文件，并对用户输入的文件名/路径进行适当的清理和验证，防止路径遍历等安全风险。 