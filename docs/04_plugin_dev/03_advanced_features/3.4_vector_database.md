---
title: 使用向量数据库
description: 学习如何利用 Nekro Agent 内置的 Qdrant 向量数据库客户端，为你的插件添加基于向量相似度搜索的语义理解和信息检索能力。
---

# 使用向量数据库 (Qdrant)

Nekro Agent 集成了 [Qdrant](https://qdrant.tech/) 向量数据库，并为插件提供了访问其客户端的便捷方式。这使得插件能够利用向量相似性搜索来实现强大的语义理解、信息检索、内容推荐等功能，而无需自行搭建和管理向量数据库实例。

## 什么是向量数据库？

向量数据库专门用于存储、管理和搜索高维向量数据。这些向量通常是文本、图片、音频或其他数据的数学表示（称为嵌入, Embeddings），由深度学习模型（如 Transformer 模型）生成。

通过比较向量之间的距离或相似度（如余弦相似度、欧氏距离），向量数据库可以快速找到与给定查询向量最相似的条目，从而实现：

*   **语义搜索**：不仅仅是关键词匹配，而是理解查询的语义含义进行搜索。
*   **推荐系统**：根据用户已喜欢的内容向量，推荐相似的内容。
*   **问答系统**：将问题和文档块转换为向量，找到与问题最相关的文档块作为答案来源。
*   **异常检测**、**聚类**等。

## Nekro Agent 中的 Qdrant 集成

Nekro Agent 在其核心服务中初始化并管理了一个 Qdrant 客户端实例。插件可以通过 `nekro_agent.api.core`模块来获取这个客户端，并利用它与 Qdrant 服务器进行交互。

### 1. 获取 Qdrant 客户端

在你的插件代码中（通常是在沙盒方法或初始化方法内），你可以像这样获取 Qdrant 客户端：

```python
from nekro_agent.api import core
from qdrant_client import QdrantClient, models
from qdrant_client.http.models import PointStruct, Distance, VectorParams

async def get_my_qdrant_client() -> QdrantClient:
    qdrant_client: Optional[QdrantClient] = await core.get_qdrant_client()
    if not qdrant_client:
        core.logger.error("无法获取 Qdrant 客户端实例！请检查 Agent 核心配置。")
        # 可以根据插件逻辑决定是抛出异常还是返回 None
        raise ConnectionError("Qdrant client is not available.")
    return qdrant_client
```

`core.get_qdrant_client()` 是一个异步函数，它会返回一个已配置好的 `QdrantClient` 实例，或者在 Qdrant 未正确配置或不可用时返回 `None` (或根据 Agent 内部实现抛出异常)。因此，在使用前进行检查非常重要。

你还可以通过 `core.get_qdrant_config()` 获取 Qdrant 的连接配置信息（如 host, port, api_key 等），但这通常由 Agent 核心管理，插件开发者较少直接需要。

### 2. 插件专属的集合名称

为了避免不同插件在 Qdrant 中使用相同的集合名称造成冲突，Nekro Agent 提供了一个辅助方法 `plugin.get_vector_collection_name()` 来为你的插件生成一个唯一的、标准化的集合名称。

```python
# 在你的插件实例 (plugin) 上下文中

# 生成一个默认的集合名称，基于插件的作者和模块名
default_collection_name = plugin.get_vector_collection_name()
# 示例输出: "nekro_plugin_my_author_my_plugin_default"

# 为插件内的特定用途生成带有后缀的集合名称
specific_collection_name = plugin.get_vector_collection_name("user_documents")
# 示例输出: "nekro_plugin_my_author_my_plugin_user_documents"
```

**强烈建议**插件在 Qdrant 中创建和使用通过此方法生成的集合名称，以确保良好的隔离性和避免命名冲突。

## 常见使用流程

以下是一个插件使用 Qdrant 的典型流程：

### 1. 初始化时创建集合 (如果不存在)

在插件的 `@plugin.mount_init_method()` 中，检查并创建插件所需的 Qdrant 集合。

```python
# 在插件的初始化方法中
@plugin.mount_init_method()
async def initialize_my_plugin_collections():
    try:
        client = await get_my_qdrant_client() # 使用前面定义的辅助函数
        collection_name = plugin.get_vector_collection_name("knowledge_base") # 假设用于知识库

        # 检查集合是否存在
        try:
            await client.get_collection(collection_name=collection_name)
            core.logger.info(f"Qdrant 集合 '{collection_name}' 已存在。")
        except Exception as e: # 通常，如果集合不存在，会抛出异常
            # (更精确的异常捕获依赖于 QdrantClient 的具体行为，可能是 qdrant_client.http.exceptions.UnexpectedResponseError)
            core.logger.info(f"Qdrant 集合 '{collection_name}' 不存在，正在创建...")
            
            # 定义向量参数 (维度应与你的 embedding 模型输出一致)
            # 假设你的 embedding 模型输出 384 维向量
            vector_size = plugin.config.EMBEDDING_DIMENSION # 从插件配置获取维度
            
            await client.create_collection(
                collection_name=collection_name,
                vectors_config=models.VectorParams(
                    size=vector_size, 
                    distance=models.Distance.COSINE # 常用的距离度量：余弦相似度
                )
            )
            core.logger.success(f"Qdrant 集合 '{collection_name}' 创建成功。")

    except ConnectionError:
        core.logger.error(f"插件 '{plugin.name}' 初始化 Qdrant 集合失败：无法连接到 Qdrant。")
    except Exception as e:
        core.logger.error(f"插件 '{plugin.name}' 初始化 Qdrant 集合时发生未知错误: {e}")

```
你需要根据你的嵌入模型输出的向量维度来设置 `size`，并选择合适的 `distance` 度量（`COSINE` 通常用于文本语义相似度）。

### 2. 生成文本嵌入 (Embeddings)

要将数据存入 Qdrant 或进行搜索，首先需要将其转换为向量嵌入。这通常通过调用一个嵌入模型来完成。Nekro Agent 本身可能提供了嵌入服务，或者插件可能需要集成自己的嵌入模型/API。

```python
# 伪代码：获取文本嵌入的函数
# 实际实现可能调用 Agent 核心的 embedding 服务或第三方库/API
async def get_text_embedding(text: str, model_name: str = "default_embedding_model") -> List[float]:
    # 假设 core.embed_text(...) 是 Agent 提供的服务
    # embedding_vector = await core.embed_text(text, model=model_name)
    # return embedding_vector
    
    # 或者使用第三方库，例如 sentence-transformers (同步库，需在异步环境中妥善处理)
    # from sentence_transformers import SentenceTransformer
    # model = SentenceTransformer('all-MiniLM-L6-v2') # 应该在初始化时加载模型
    # return model.encode(text).tolist()
    
    # 示例：返回一个固定长度的随机向量 (仅用于演示结构)
    import random
    vector_size = plugin.config.EMBEDDING_DIMENSION
    return [random.random() for _ in range(vector_size)]
```
确保插件配置中包含嵌入模型的维度 (`EMBEDDING_DIMENSION`)。

### 3. 向集合中添加数据 (Upsert Points)

获取文本嵌入后，你可以将数据点 (Points) 添加到 Qdrant 集合中。每个点通常包含一个 ID、一个向量 (embedding) 和一个可选的载荷 (payload)。Payload 可以存储原始文本或其他元数据。

```python
import uuid

@plugin.mount_sandbox_method(SandboxMethodType.BEHAVIOR, "add_document_to_kb", "添加文档到插件知识库")
async def add_document(ctx: AgentCtx, document_text: str, document_id: Optional[str] = None) -> str:
    try:
        client = await get_my_qdrant_client()
        collection_name = plugin.get_vector_collection_name("knowledge_base")
        embedding_model = plugin.config.EMBEDDING_MODEL_FOR_KB

        vector = await get_text_embedding(document_text, model_name=embedding_model)
        
        point_id = document_id or str(uuid.uuid4()) # 如果未提供 ID，则生成一个

        await client.upsert(
            collection_name=collection_name,
            points=[
                models.PointStruct(
                    id=point_id,
                    vector=vector,
                    payload={"text": document_text, "source": "plugin_upload", "created_at": time.time()}
                )
            ]
        )
        return f"文档 (ID: {point_id}) 已成功添加到知识库 '{collection_name}'。"
    except Exception as e:
        core.logger.error(f"添加文档到 Qdrant 失败: {e}")
        return f"添加文档失败: {e}"
```

### 4. 搜索相似向量 (Semantic Search)

这是向量数据库的核心功能。给定一个查询文本，先将其转换为查询向量，然后使用该向量在 Qdrant 集合中搜索最相似的点。

```python
@plugin.mount_sandbox_method(SandboxMethodType.AGENT, "search_kb_semantic", "在插件知识库中进行语义搜索。")
async def search_knowledge_base_semantic(ctx: AgentCtx, query_text: str, top_k: int = 3) -> str:
    try:
        client = await get_my_qdrant_client()
        collection_name = plugin.get_vector_collection_name("knowledge_base")
        embedding_model = plugin.config.EMBEDDING_MODEL_FOR_KB

        query_vector = await get_text_embedding(query_text, model_name=embedding_model)

        search_results = await client.search(
            collection_name=collection_name,
            query_vector=query_vector,
            limit=top_k, # 返回最相似的 top_k 个结果
            with_payload=True # 同时返回 payload 数据
        )

        if not search_results:
            return f"在知识库中未能找到与 '{query_text}' 相关的语义匹配结果。"

        results_str = f"关于 '{query_text}' 的语义搜索结果 (最相关的前 {len(search_results)} 条):\n"
        for i, hit in enumerate(search_results):
            results_str += f"{i+1}. (ID: {hit.id}, 相似度: {hit.score:.4f})\n"
            if hit.payload:
                results_str += f"   内容: {hit.payload.get('text', '')[:200]}...\n"
        
        return results_str
    
    except Exception as e:
        core.logger.error(f"在 Qdrant 中搜索失败: {e}")
        return f"知识库搜索失败: {e}"
```
Qdrant 的 `search` 方法会返回一个包含 `ScoredPoint` 对象的列表，每个对象都有 `id`, `score` (相似度分数), `vector` (可选), 和 `payload` (可选)。

## 其他 Qdrant 操作

Qdrant 客户端还支持许多其他操作，例如：

*   **删除点 (Points)**: `client.delete_points(...)`
*   **更新点 (Points)**: `client.update_points_payload(...)`, `client.overwrite_payload(...)`
*   **按 ID 检索点**: `client.retrieve(...)`
*   **管理集合**: `client.delete_collection(...)`, `client.update_collection_aliases(...)`
*   **使用过滤器进行搜索**: 在 `search` 方法中使用 `query_filter` 参数，根据 payload 中的字段进行结构化过滤，结合向量搜索实现混合搜索。
*   **推荐 API**: `client.recommend(...)` 基于一个或多个点 ID 查找相似点。

请参考 [Qdrant官方文档](https://qdrant.tech/documentation/) 和 [qdrant-client Python库文档](https://github.com/qdrant/qdrant-client) 获取更详细的 API 信息和高级用法。

## 注意事项

*   **Embedding 模型的一致性**：用于索引数据和用于查询的 Embedding 模型必须是相同的，否则相似度计算没有意义。
*   **向量维度**：Qdrant 集合中配置的向量维度必须与 Embedding 模型输出的维度完全一致。
*   **错误处理**：与 Qdrant 服务器的交互可能会因为网络问题、配置错误或操作不当而失败。务必在插件代码中添加充分的错误处理逻辑。
*   **性能**：对于非常大的数据集，考虑数据的分片、批量操作以及 Qdrant 的性能调优（如索引类型、HNSW参数等）。
*   **成本与资源**：虽然 Nekro Agent 可能提供了 Qdrant 实例，但大规模使用仍可能涉及成本和资源消耗，需根据实际情况评估。

通过集成 Qdrant，Nekro Agent 插件可以轻松实现复杂的语义理解和智能检索功能，极大地增强 AI 的能力和用户体验。 